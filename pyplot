#!/usr/bin/env python

# -------------- (I) IMPORT LIBRARIES ------------------------
from math import *
import sys
import os
import subprocess
import re
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import MySQLdb as mdb
import getpass
# ------------------- xxx -------------------- (I) LIBRARIES


# ------------------ (II) what the program does ------------------
"""
The program plots datafile(s) or table(s) from a database
with various user provided plot options, and outputs a pdf plot.
The plot is automatically opened using evince, and after
the evince-window is closed, the plotted file is deleted.
It is primarily meant to view data on the fly!

case Datafile:
   The command line arguments should be of the form
   ( and must appear in the order specified )
   1> datafiles (1 or many)
      Each datafile must have the same number of columns
      comment lines in data files must begin with '#'
      ( NOT comma separated data files! )
   2> keyword "cols" n
      where, n (integer) is the total column number
      in each data file
   3> plot options or options (if any) in ANY order
      (I) Basic options provided as default:
       Ia> absy, plots abs(Y) vs X
       Ib> absx, plots Y vs abs(X)
       Ib> logy, plots logscale abs(Y) vs X
       Ic> logx, plots Y vs logscale abs(x) 
       Id> logxy, plots log-log scale abs(Y) vs abs(X)
     (II) user defined options on command prompt:
       currently these options are limited to
       simple arithmetic operations of the form:
       a + b*r**c,
       where r is either x|y|xy
       and a,b,c are floats, both +ve and -ve.
       The entered expression has to conform to the
       above form, but need not provide the full expr,
       i.e., 3.0+y is a valid expression.

case Database(DB) :
   The command line arguments should be of the form
   ( and must appear in the order specified )
   1> keyword "db"
   2> database info in the same order: host, user, database, table(s)
   3> keyword "use" to mark end of table names
   4> plot options as in the datafile case
   5> after pressing ENTER, there will be a password prompt for the DB.
"""
# -------------------- xxx ----------- (II) preliminary documentation


# ---------------------(III) FIGURE SETTINGS -------------------
"""
Some of the setting for the plots. These are the
default settings for all figure.
"""
# figure size
plt.rc('figure', figsize=(8.5, 5.0))
# font size for axes tics
plt.rc('font', size=15.0) 
# linewidth
plt.rc('lines', linewidth=1.8)
# axes or frame 
plt.rc('axes', linewidth=1.5)
# xticks
plt.rc('xtick.major', size=6.0, width=1.5)
plt.rc('xtick.minor', size=3.0, width=1.5)
# yticks
plt.rc('ytick.major', size=6.0, width=1.5)
plt.rc('ytick.minor', size=3.0, width=1.5)

# line colors, blue, black, red, magenta, green
colors = ['b','k','r','m','g','c']
# --------------------------- xxx --------------- (III) FIGURE SETTINGS


# ------------------------ (IV) base class ----------------------
class BaseParse:
    """
    A base class that would parse command-line plot options.
    
    i.e., parse command-line arguments that would appear both for
    the database and datafile cases, and also create some GENERIC
    FUNCTIONS (independent of command-line arguments) that would
    work for both cases.

    There is no __init__ in this BaseParse class.
    The two subclasses, a> Datafile, b>Database,
    has appropriate __init__ methods.
    """

    # basic or default plot options that are
    # provided or recognized by the program
    # irrespective of any case
    plot_options_basic = ['absy','absx','absxy','logy','logx','logxy']

    # we now provide the framework for
    # some user definable options
    # regex patterns of the form
    # 1> a + b*r**c
    # 2> a + b*r*c
    # 3> a + b*r + c
    # where a,b,c are +/-floats, and if zero, need not be entered
    # and r=> xy|x|y
    # we need to parse all the individual elements
    # such as a,b,+-*,r,c
    # so we use parenthesis '()' to create appropriate groups
    # that will be easily identified in re.match.groups()
    # float regex: r'[-+]?[0-9]*\.?[0-9]+'
    # (note:) these options hold for both database/datafile case    
    expr_pattern = re.compile(r'([-+]?)([0-9]*\.?[0-9]*)'
                              r'([-+*]?)([0-9]*\.?[0-9]*)'
                              r'\*?'
                              r'([x-y]+)'
                              r'([*^]{0,2})'
                              r'[(]?'
                              r'([-+]?)([0-9]*\.?[0-9]*)'
                              r'[)]?')

    #def __init__(self,arg_list):
        # arg_list is the sys.argv command-line options
        #self.arglist = arg_list

    def _parsedOptions(self,plot_options_given):
        # ( plot_options_given are the 'raw' or 'un-edited' 
        # user-given PLOT-OPTIONS on the command-line
        # and NOT the entire list of command-line arguments )
        # the entered user defined options may not conform
        # to the allowed expression patterns or basic options
        # so, we parse the user defined option(s),
        # check the conformity, and then store
        # the associated parsed info replacing the given expression
        for i,e in list( enumerate(plot_options_given) ):
            if e not in self.plot_options_basic:
                m = self.expr_pattern.match(e)
                if m:
                    # we replace the user defined options
                    # that are beyond the default options
                    # with parsed expressions using regex.groups
                    plot_options_given[i] = m.groups()
                else:
                    s1 = 'un-supported user defined option: ' + str(e)
                    s2 = 'allowed options are of the form:'
                    s3 = '1> a+b*r**c or a+b*r^c, 2> a+b*r*c, 3> a+b*r+c'
                    s4 = 'r => xy|x|y and a,b,c are +/-floats'
                    s5 = 'if any of a,b,c = 0.0, they need not be mentioned'
                    s6 = 'resulting plot with other options (if any)'
                    print '\n'+s1+'\n'+s2+'\n'+s3+'\n'+s4+'\n'+s5+'\n'+s6+'\n'
                    # we flag this 'wrong' user-defined option
                    # and will remove it later
                    plot_options_given[i] = 'del'
                                                                               
        # remove the 'wrong' plot options which has been flagged           
        for e in plot_options_given:
            if e == 'del':
                plot_options_given.remove(e)
        # return the list of parsed plot-options
        return plot_options_given
    
    def _dfTransform(self,dfX,dfY,ops):
        # creating a function that will take
        # 1> a user defined plot options
        # ( that are outside basic options )
        # 2> two dataframes, dfX and dfY
        # dfX => X column, and dfY => Y columns
        # and return the transformed dataframes
        # after applying the plot options
        def sign(str):
            # function to determine positive or negative
            if str == '+' or str == '':
                c = 1.0
            else:
                c = -1.0
            return c

        # function to transform dataframes
        # ops is one of the plot options
        if ops[7]:
            c = sign( ops[6] )*float( ops[7] )
        else:
            c = 1
        if ops[1] and ops[3]:
            a = sign( ops[0] )*float( ops[1] )
            b = sign( ops[2] )*float( ops[3] )
        if not ops[3] and ops[1]:
            if ops[2] == '+' or ops[2] == '-':
                a = sign( ops[0] )*float( ops[1] )
                b = sign( ops[2] )*1.0
            elif not ops[2] or ops[2] == '*':
                a = 0.0
                b = sign( ops[0] )*float( ops[1] )
        if not ops[1] and not ops[3]:
            a, b = 0.0, 1.0
        if ops[5] == '**' or ops[5] == '^':
                dfY_tmp = a + b*dfY**c
                dfX_tmp = a + b*dfX**c
        elif not ops[5] and ops[6]:
                dfY_tmp = a + b*dfY + c
                dfX_tmp = a + b*dfX + c
        else: # ops[5] = '*'
                dfY_tmp = a + b*dfY*c
                dfX_tmp = a + b*dfX*c
        if 'y' in ops:
            dfY = dfY_tmp
        elif 'x' in ops:
            dfX = dfX_tmp
        else:
            dfY = dfY_tmp
            dfX = dfX_tmp
        return dfX, dfY

    def _readcsv(self,filename,col=[]):
        """
        Generic function to create dataframe from a corresponding datafile.
        
        It takes as input the
        1> datafile name ( filename ) 
        2> the column names ( default, empty list ),
        and outputs a dataframe.
        
        The input file has data in the form of columns, separated by
        white space ( and NOT comma separated ).
        
        The data in the input file has to be of the form X, Y0, Y1, Y2, etc.,
        where we are interested in plotting Y's vs X as a line plot.
        All X and Y's must be numeric.
        
        The data file can have comments where the comment lines has to
        start with the character "#".
        
        We later assign default column names X, Y0, Y1, Y2, etc to all columns.
        """
        # drop comment lines
        # backfill NAN values
        f = pd.read_csv(filename,
                        comment='#',
                        header=None,
                        names=col,
                        sep=r"\s+",
                        skipinitialspace=True).dropna()
        f = f.convert_objects(convert_numeric=True)
        f = f.fillna(method='bfill') 
        f.index = range(f.shape[0])
        return f

    def _readsql(self,table,con):
        """
        Generic function to create dataframe from TABLE from a DataBase.
        
        It takes as input the
        1> table name ( table ) 
        2> DB conection info ( con ),
        and outputs a dataframe.
        
        The data in the input table has to be of the form X, Y0, Y1, Y2, etc.,
        where we are interested in plotting Y's vs X as a line plot.
        All X and Y's must be numeric.
        """
        df = pd.read_sql('SELECT * FROM %s'%table,con)
        return df

    def _dfPlot(self,
                dframes,
                figsize=[13,4],
                nrows=1,ncols=1,
                legend=True,
                logx=False,logy=False,loglog=False,
                xlabel='',ylabel='',
                titles=[''],
                save=True,
                filename=''):
        """
        Generic function for plotting a list of dataframes.

        Input: A list of dataframes, containing one or several elements.
               Each dataframe corresponds to a given datafile.
        Output: A single pdf plot of all the dataframes in a grid-like view.
        """
        fig = plt.figure(figsize=figsize)
        # max number of figures
        # that can be included 
        # in the grid-view
        figs = nrows*ncols
        
        # number of dataframes
        # we want to plot
        plts = len( dframes )
    
        for i in xrange(plts):
            ax = fig.add_subplot(nrows,ncols,i+1)
            if i>=len(titles):
                titles.append('')               
            ax = dframes[i].plot(x=dframes[i].columns.values[0],
                             logy=logy,
                             logx=logx,
                             loglog=loglog,
                             color=colors,
                             legend=legend,
                             ax=ax)      
            ax.legend(loc='best', fancybox=True, framealpha=0.5)
        
        # some text
        if xlabel:
            ax.set_xlabel(xlabel, fontsize=22)
        ax.set_ylabel(ylabel, fontsize=22)
        ax.set_title(titles[i], fontsize=20, y=1.05)
        
        # grid display spacing
        fig.tight_layout(w_pad=5.0, h_pad=2.0)
        if save:
            if filename:
                fig.savefig(filename)
            else:
                fig.savefig('fig.pdf')
# --------------------- xxx ------------ (IV) base class


# ------------------------ (V) datafile class ----------------------
class Datafile(BaseParse):
    """
    Class for the case of datafiles as command-line input.

    It inherits from class BaseParse, and adds new "datafile"
    specific class methods.
    """
    def __init__(self,arg_list):
        # arg_list is in general sys.argv
        # i.e, the list of command-line arguments
        self.arglist = arg_list


    def _readColumns(self):
        """
        Finding out the number of columns in each data file.

        Uses the "cols" argument in the sys.argv list.
        Returns:
        a> No. of datafiles
        b> assigned column names, as X, Y0, Y1, Y2, etc.
        """
        if 'cols' not in self.arglist:
            print 'enter the number of columns as cols int'
            sys.exit()
        else:
            for i,e in list( enumerate(self.arglist) ):
                if e=='cols':
                    try:
                        ncols = int( self.arglist[i+1] )
                    except TypeError:
                        print 'enter column no. (int) after cols'
                        sys.exit()
                    except ValueError:
                        print 'enter column no. (int) after cols'
                        sys.exit()
                    end = i # no. of datafiles!
        # naming the cols of each dataframe as X, Y0, Y1, etc
        # to be used by the dataframes to be created
        col = ['X']
        for i in xrange(1,ncols):
            label = 'Y'+str(i-1)
            col.append(label)
        return end, col

    def _dframesList(self):
        """
        Parsing command-line and creating dataframes from given data files.
        
        ( NOTE: all datafiles are entered before keyword 'cols' ).
        Creating a list of dataframes AFTER applying the given plot
        options to the data, both basic and user defined plot options
        are implemented serially, i.e., in the same order as they appear
        in the command line.
        ( only 'log-scale' option will be implemented at the end. )
        """
        end, col = self._readColumns()
        plot_options_given = self._parsedOptions( self.arglist[end+2:] )
        plot_options_basic = self.plot_options_basic
        
        # regex for file name
        # we only pick the file name if it has en extension
        # in the absence of which, we name it as datafile 1, etc
        expr_filename = re.compile(r'\w+[-_]?\w+[.]\w+')
        
        dframes = []
        titles = []
        for i in xrange( 1,end ):
            try:
                # checking if datafile exists
                # or if no. of cols entered is correct
                df = self._readcsv( self.arglist[i],col )
            except IOError:
                # file does not exist
                if self.arglist[i] not in plot_options_basic:
                    s = 'file ' + str( self.arglist[i] ) + ' does not exist'
                    print s
                    sys.exit()
                else:
                    s = 'plot options must appear after cols'
                    print s
                    sys.exit()
            except ValueError:
                # wrong no. of cols entered
                # NOTE: ensure each datafile has same
                # number of columns
                s1 = 'enter correct no. of columns in each file'
                s2 = ' or check their compatibility'
                print s1+s2
                sys.exit()
                # creating plot name from the datafile name
            m = expr_filename.search(self.arglist[i])
            if m:
                titles.append( m.group() )
            else:
                titles.append( 'datafile '+str(i) )
            if plot_options_given:
                # split the dataframe into X and Y's
                dfX = df.X
                dfY = df.ix[:,1:]
                for e in plot_options_given:
                    # take care of basic options
                    # except the log-scaling
                    if e == 'absy':
                        dfY = dfY.abs()
                    elif e == 'absx':
                        dfX = dfX.abs()
                    elif e == 'absxy':
                        dfY = dfY.abs()
                        dfX = dfX.abs()
                    # take care of user-defined options
                    elif e not in plot_options_basic[3:]:
                        dfX, dfY = self._dfTransform(dfX,dfY,e)
                # take care of the log-scaling
                # we take the absolute value
                # after having taken care of all
                # other plot options
                if 'logy' in plot_options_given:
                    dfY = dfY.abs()
                elif 'logx' in plot_options_given:
                    dfX = dfX.abs()
                elif 'logxy' in plot_options_given:
                    dfY = dfY.abs()
                    dfX = dfX.abs()
                # collecting dfX and dfY to get back df
                dfY.insert(0,'X',dfX)
                df = dfY
                dframes.append( df )
            else:
                # no plot options
                dframes.append( df )
        return dframes, titles

    def finalPlot(self):
        """
        Plots the dataframes and saves the plotted file as a pdf.

        Returns the file name of the plotted file.
        """
        end, col = self._readColumns()
        # no. of plots or data files
        nplots = end - 1
        
        # figuring out the number of columns
        # and rows for the grid-plot
        # depends on the number of datafiles
        if nplots%2==0:
            nrows = nplots/2
            ncols = 2
        elif nplots%2==1:
            if nplots/2==0:
                nrows = 1
                ncols = 1
            else:
                nrows = nplots/2+1
                ncols = 2

        # creating a 'hopefully' unique file-name
        # by appending the pid to the name
        filename = 'tmppyplot' + str( os.getpid() ) + '.pdf'
        
        dframes, titles = self._dframesList()
        if 'logy' in sys.argv:
            self._dfPlot(dframes,
                   nrows=nrows,
                   ncols=ncols,
                   figsize=[7.5*ncols,5*nrows],
                   logy=True,
                   save=True,
                   titles=titles,
                   filename=filename) 
        elif 'logx' in sys.argv:
            self._dfPlot(dframes,
                   nrows=nrows,
                   ncols=ncols,
                   figsize=[7.5*ncols,5*nrows],
                   logx=True,
                   save=True,
                   titles=titles,
                   filename=filename)
        elif 'logxy' in sys.argv:
            self._dfPlot(dframes,
                   nrows=nrows,
                   ncols=ncols,
                   figsize=[7.5*ncols,5*nrows],
                   loglog=True,
                   save=True,
                   titles=titles,
                   filename=filename)
        else:
            self._dfPlot(dframes,
                   nrows=nrows,
                   ncols=ncols,
                   figsize=[7.5*ncols,5*nrows],
                   save=True,
                   titles=titles,
                   filename=filename)
        return filename
# --------------------- xxx ------------ (V) datafile class


# ------------------------ (VI) database class ----------------------
class Database(BaseParse):
    """
    Class for the case of tables from a database as command-line input.

    It inherits from class BaseParse, and adds new "database"
    specific class methods.
    """
    def __init__(self,arg_list):
        # arg_list is in general sys.argv
        # i.e, the list of command-line arguments
        self.arglist = arg_list

    def _tables(self):
        # finding out the number of tables entered by the user
        # "use" marks the end of table names
        if 'use' not in self.arglist:
            print 'missing keyword use which marks end of table names'
            sys.exit()
        for i,e in list( enumerate(self.arglist) ):
            if e=='use':
                end = i
        return end

    def _dframesList(self):
        """
        Parsing command-line and creating dataframes from given DB TABLES.
        
        ( NOTE: all tables are entered before keyword 'use' ).
        Creating a list of dataframes AFTER applying the given plot
        options to the data, both basic and user defined plot options
        are implemented serially, i.e., in the same order as they appear
        in the command line.
        ( only 'log-scale' option will be implemented at the end. )
        """
        end = self._tables()
        plot_options_given = self._parsedOptions( self.arglist[end+1:] )
        plot_options_basic = self.plot_options_basic
        
        # regex for table name
        expr_filename = re.compile(r'\w+[-_]?\w+')

        # connect to database
        host = self.arglist[2]
        user = self.arglist[3]
        database = self.arglist[4]
        passwd = getpass.getpass()
        try:
            # check if succesful connection to DB is made
            con = mdb.connect( host,user,passwd,database )
        except mdb.OperationalError:
            print 'Could not connect to database '+ database
            sys.exit()
        
        dframes = []
        titles = []
        for i in xrange( 5,end ):
            try:
                # checking if table exists
                df = self._readsql( self.arglist[i],con )
            except mdb.ProgrammingError:
                # error reading table
                print 'Table does not exist'
                sys.exit()
            m = expr_filename.search(self.arglist[i])
            if m:
                titles.append( m.group() )
            else:
                titles.append( 'datafile '+str(i) )
            if plot_options_given:
                # split the dataframe into X and Y's
                dfX = df.ix[0,:]
                dfY = df.ix[:,1:]
                for e in plot_options_given:
                    # take care of basic options
                    # except the log-scaling
                    if e == 'absy':
                        dfY = dfY.abs()
                    elif e == 'absx':
                        dfX = dfX.abs()
                    elif e == 'absxy':
                        dfY = dfY.abs()
                        dfX = dfX.abs()
                    # take care of user-defined options
                    elif e not in plot_options_basic[3:]:
                        dfX, dfY = self._dfTransform(dfX,dfY,e)
                # take care of the log-scaling
                # we take the absolute value
                # after having taken care of all
                # other plot options
                if 'logy' in plot_options_given:
                    dfY = dfY.abs()
                elif 'logx' in plot_options_given:
                    dfX = dfX.abs()
                elif 'logxy' in plot_options_given:
                    dfY = dfY.abs()
                    dfX = dfX.abs()
                # collecting dfX and dfY to get back df
                dfY.insert(0,'X',dfX)
                df = dfY
                dframes.append( df )
            else:
                # no plot options
                dframes.append( df )
        return dframes, titles

    def finalPlot(self):
        """
        Plots the dataframes and saves the plotted file as a pdf.

        Returns the file name of the plotted file.
        """
        end = self._tables()
        # no. of plots or data files
        nplots = end - 1
        
        # figuring out the number of columns
        # and rows for the grid-plot
        # depends on the number of datafiles
        if nplots%2==0:
            nrows = nplots/2
            ncols = 2
        elif nplots%2==1:
            if nplots/2==0:
                nrows = 1
                ncols = 1
            else:
                nrows = nplots/2+1
                ncols = 2

        # creating a 'hopefully' unique file-name
        # by appending the pid to the name
        filename = 'tmppyplot' + str( os.getpid() ) + '.pdf'
        
        dframes, titles = self._dframesList()
        if 'logy' in sys.argv:
            self._dfPlot(dframes,
                   nrows=nrows,
                   ncols=ncols,
                   figsize=[7.5*ncols,5*nrows],
                   logy=True,
                   save=True,
                   titles=titles,
                   filename=filename) 
        elif 'logx' in sys.argv:
            self._dfPlot(dframes,
                   nrows=nrows,
                   ncols=ncols,
                   figsize=[7.5*ncols,5*nrows],
                   logx=True,
                   save=True,
                   titles=titles,
                   filename=filename)
        elif 'logxy' in sys.argv:
            self._dfPlot(dframes,
                   nrows=nrows,
                   ncols=ncols,
                   figsize=[7.5*ncols,5*nrows],
                   loglog=True,
                   save=True,
                   titles=titles,
                   filename=filename)
        else:
            self._dfPlot(dframes,
                   nrows=nrows,
                   ncols=ncols,
                   figsize=[7.5*ncols,5*nrows],
                   save=True,
                   titles=titles,
                   filename=filename)
        return filename
# --------------------- xxx ------------ (VI) database class


# ----------------------- (VII) class instantiation -----------------------
# creating instance of database or datafile
# as per the command-line information
# its kind of "case-select"-ion
if 'db' in sys.argv:
    plotData = Database( sys.argv )
else:
    plotData = Datafile( sys.argv )
# ---------------------- xxx ---------- (VII) class instantiation


# ----------------- (VIII) VIEWING THE PLOTS -----------
# use evince to view the plots
# it deletes the created .pdf plot files after viewing
# i.e., after the plot window is closed

filename = plotData.finalPlot()
readpdf = subprocess.Popen(['evince', filename], shell=False)
readpdf.wait()      # wait till evince window is closed
subprocess.Popen(['rm', filename], shell=False )
# --------------- xxx -------- (VIII) VIEWS
